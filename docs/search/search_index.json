{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"OQL"},{"location":"/index.html#oql","text":"Object Query Language (OQL) is a simple relational database query language inspired by GraphQL and SQL, but designed to be translated query-for-query into database engine specific SQL, with identical behaviour across supported engines.","title":"OQL"},{"location":"/introduction.html","text":"","title":"Introduction"},{"location":"/introduction.html#introduction","text":"","title":"Introduction"},{"location":"/introduction.html#overview","text":"OQL is a language for querying a relational database. The query syntax draws inspiration from GraphQL and is similar, but with many differences. Some capabilities missing from GraphQL have been added, and some capabilities found in GraphQL have a different syntax. We believe that much of conventional SQL syntax is still preferable to creating a completely new syntax for every single feature of the query language (i.e., conventional syntax wherever possible). However, whereas SQL can be seen as a “low level” relational query language, OQL takes a higher level Entity-Relationship (ER) Model view of the database.\nThe name “OQL” refers to both a software library, and a query language implemented within that library. The OQL library provides support for data retrieval (via the OQL query language) as well as a query builder for constructing queries in programmatically. There are also class methods for performing all kinds of mutations, including mutations that support the ER view of the database. Furthermore, query and mutation operations all abide by the supplied ER data model.\nSome features of OQL include:\nthe query language is similar to GraphQL in that query results have exactly the structure requested in the query (i.e., you get what you ask for) uses a very simple Entity-Relationship Model description of the database works with the PostgreSQL database system designed to work with existing databases without having to change the database at all","title":"Overview"},{"location":"/introduction.html#relationships","text":"OQL recognizes all the various kinds of entity relationships, and provides a way to explicitly define them:\nOne-to-Many The one-to-many relationship means that an object of some entity A can relate to any number of objects of some entity B. It is possible for A and B to be the same entity: entities can be in a self relationship. Furthermore, that self relationship can be indirect with intermediate entities. The one-to-many relationship is just the flip version of many-to-one: if A is one-to-many in how it relates to B, then B is many-to-one in how it relates to A. Many-to-one The many-to-one relationship means that any number of objects of some entity A can relate to a single object of some entity B. Many-to-many The many-to-many relationship means that any number of objects of some entity A can relate to any number of objects of some entity B. In OQL, this is accomplished by both defining that the relationship exists and defining a junction or link entity to facilitate the links between A and B. One-to-one The one-to-one relationship that an object of some entity A can relate to a single object of some entity B and no more.","title":"Relationships"},{"location":"/installation.html","text":"","title":"Installation"},{"location":"/installation.html#installation","text":"","title":"Installation"},{"location":"/installation.html#typescript-javascript","text":"There is a Node.js module available through the npm registry.\nInstall using the npm install command:\nnpm install @vinctus/oql\nTypeScript declarations are included in the package.","title":"TypeScript/JavaScript"},{"location":"/installation.html#scala-js","text":"There is a Scala.js library available through Github Packages.\nAdd the following lines to your build.sbt:\nexternalResolvers += \"OQL\" at \"https://maven.pkg.github.com/vinctustech/oql\"\n\nlibraryDependencies += \"com.vinctus\" %%% \"-vinctus-oql\" % \"1.1.29\"\n\nCompile / npmDependencies ++= Seq(\n  \"pg\" -> \"8.10.0\",\n  \"@types/pg\" -> \"8.6.6\",\n  \"source-map-support\": \"0.5.21\"\n)","title":"Scala.js"},{"location":"/tutorial.html","text":"","title":"Tutorial"},{"location":"/tutorial.html#tutorial","text":"We present a fully explained tutorial example showing how to apply OQL to an SQL database. To begin, we need to create a dockerized PostgreSQL database. Therefore, you will need to have docker installed.\nSee Examples for other examples.\nThis example creates a very simple employee database where employees have a manager and a department (among other things), so that the employees and their managers are in a many-to-one relationship. This example also demonstrates self-referential entities. Employees and departments are also in a many-to-one relationship. The database definition purposely contains a few oddities so that certain OQL features can be demonstrated.","title":"Tutorial"},{"location":"/tutorial.html#setup-postgresql","text":"We need to get PostgreSQL running in a docker container:\ndocker pull postgres\ndocker run --rm --name pg-docker -e POSTGRES_PASSWORD=docker -d -p 5432:5432 postgres\nThe PostgreSQL client (psql) should be installed. If necessary, it can be installed with the command\nsudo apt-get install postgresql-client","title":"Setup PostgreSQL"},{"location":"/tutorial.html#create-the-database","text":"Run psql with the command:\npsql -h localhost -U postgres -d postgres\nEnter password docker.\nCreate a simple database by copy-pasting the following (yes, all in one shot) at the psql prompt:\nCREATE DATABASE employees;\n\nCREATE TABLE department (\n  dep_id SERIAL PRIMARY KEY,\n  dep_name TEXT\n);\n\nCREATE TABLE employees (\n  emp_id SERIAL PRIMARY KEY,\n  emp_name TEXT,\n  job_title TEXT,\n  manager_id INTEGER REFERENCES employees,\n  dep_id INTEGER REFERENCES department\n);\n\nINSERT INTO department (dep_id, dep_name) VALUES\n  (1001, 'FINANCE'),             \n  (2001, 'AUDIT'),\n  (3001, 'MARKETING');\n\nINSERT INTO employees (emp_id, emp_name, job_title, manager_id, dep_id) VALUES\n  (68319, 'KAYLING', 'PRESIDENT', null, 1001),\n  (66928, 'BLAZE', 'MANAGER', 68319, 3001),\n  (67832, 'CLARE', 'MANAGER', 68319, 1001),\n  (65646, 'JONAS', 'MANAGER', 68319, 2001),\n  (67858, 'SCARLET', 'ANALYST', 65646, 2001),\n  (69062, 'FRANK', 'ANALYST', 65646, 2001),\n  (63679, 'SANDRINE', 'CLERK', 69062, 2001),\n  (64989, 'ADELYN', 'SALESREP', 66928, 3001),\n  (65271, 'WADE', 'SALESREP', 66928, 3001),\n  (66564, 'MADDEN', 'SALESREP', 66928, 3001),\n  (68454, 'TUCKER', 'SALESREP', 66928, 3001),\n  (68736, 'ANDRES', 'CLERK', 67858, 2001),\n  (69000, 'JULIUS', 'CLERK', 66928, 3001),\n  (69324, 'MARKER', 'CLERK', 67832, 1001);","title":"Create the database"},{"location":"/tutorial.html#entity-relationship-er-model","text":"The SQL database that we just created could be modeled using the following ER diagram.\nWe must now create a data model that OQL can understand which captures all the relationships (including the two relationships that the employee entity has to itself).","title":"Entity-Relationship (ER) Model"},{"location":"/tutorial.html#create-the-data-model","text":"Create a text file called data-model and copy the following text into it.\nentity employee (employees) {\n *emp_id: integer\n  name (emp_name): text\n  job_title: text\n  manager (manager_id): employee\n  department (dep_id): department\n  subordinates: [employee]\n}\n\nentity department {\n *dep_id: integer\n  name (dep_name): text\n  employees: [employee]\n}\nThe data model describes the parts of the database available for querying. It’s not necessary to describe every field of every table in the database, only what is being retrieved with OQL. However, primary keys of tables that are being queried should always be included, even if you’re not interested in retrieving the primary keys themselves.\nWe’d like to look at the data model in some detail to explain what’s going on. If you’d rather skip ahead and get on with the tutorial, then go to Many-to-one Query.\nThe above data model describes to OQL the database that we just created. There’s an entity definition corresponding to each table in the database. Each entity has an attribute definition corresponding to each column in the corresponding table, and in OQL it’s possible to have attributes that don’t correspond to any declared column.\nThe first line of the data model\nentity employee (employees) {\nmeans that the entity employee corresponds to table employees in the actual database. This means that table names in an SQL database can be aliased and frequently are, but it’s optional.\nThe second line\n*emp_id: integer\nmeans that emp_id is the primary key, signified by the *, in the corresponding table, and that it has an 32-bit integer type.\nThe third line\nname (emp_name): text\nsays that the table has a column called emp_name with a variable character string type, but that we want name to be the alias. Attribute aliasing is optional, but is very frequently done.\nLine five\nmanager (manager_id): employee\nsays that the table has a column called manager_id which is a foreign key referencing the table corresponding to entity employee, and we would like manager to be the alias for that attribute. This attribute is said to have an “entity” type, and puts the employee entity in a many-to-one relationship with itself.\nThe sixth line\ndepartment (dep_id): department\nmeans that entity employee is also in a many-to-one relationship with entity department (since dep_id is a foreign key).\nNote Entities can be defined in any order. In the above attribute definition, entity department is being referenced even thought its definition comes after.\nOn line thirteen within the department entity definition we find\nemployees: [employee]\nwhich defines an attribute called employees with the “entity array” type [employee]. This attribute doesn’t correspond to any column in the table, but rather asserts the one-to-many relationship that entity department has to entity employee, and facilitates queries to department that presuppose that the relationship exists.\nNote OQL checks the internal correctness of the entire data model. Specifically, whether entity array type attributes have a corresponding referencing entity type attribute.","title":"Create the Data Model"},{"location":"/tutorial.html#many-to-one-query","text":"Run the following TypeScript program:\nimport { OQL } from '@vinctus/oql'\nimport fs from 'fs'\n\nconst oql = new OQL(\n  fs.readFileSync('data-model').toString(),\n  'localhost',\n  5432,\n  'postgres',\n  'postgres',\n  'docker',\n  false,\n  0,\n  10\n)\n\noql\n  .queryMany(\n    `\n    employee { \n      name manager: manager.name department { name }\n    } [job_title = 'CLERK']`\n  )\n  .then((res: any) => console.log(JSON.stringify(res, null, 2)))\nOutput:\n[\n  {\n    \"name\": \"JULIUS\",\n    \"manager\": \"BLAZE\",\n    \"department\": {\n      \"name\": \"MARKETING\"\n    }\n  },\n  {\n    \"name\": \"MARKER\",\n    \"manager\": \"CLARE\",\n    \"department\": {\n      \"name\": \"FINANCE\"\n    }\n  },\n  {\n    \"name\": \"ANDRES\",\n    \"manager\": \"SCARLET\",\n    \"department\": {\n      \"name\": \"AUDIT\"\n    }\n  },\n  {\n    \"name\": \"SANDRINE\",\n    \"manager\": \"FRANK\",\n    \"department\": {\n      \"name\": \"AUDIT\"\n    }\n  }\n]\nThe query\nemployee { \n  name manager: manager.name department { name }\n} [job_title = 'CLERK']\nis asking for the names of employees with job title “CLERK” as well as the names of their manager and department. The query is sort-of unnatural because we’re asking for the names of the manager and department in two different ways in order to demonstrate different features of OQL.\nIn the above query, manager: manager.name in the projection (i.e., what’s between the { … } after the entity you’re querying) says that we want to get just the string value of the name of the employee’s manager, and we want the associated property name in the result object to be manager. Whereas, department { name } says that we want a result object corresponding to the department, with implied property name department, but we only want the name property, excluding the dep_id property, which we would also have gotten had we simply written department without the { name } after it.","title":"Many-to-one Query"},{"location":"/tutorial.html#one-to-many-query","text":"Run the following TypeScript program:\nimport { OQL } from '@vinctus/oql'\nimport fs from 'fs'\n\nconst oql = new OQL(\n  fs.readFileSync('data-model').toString(),\n  'localhost',\n  5432,\n  'postgres',\n  'postgres',\n  'docker',\n  false,\n  0,\n  10\n)\n\noql\n  .queryMany(\n    `\n    employee {\n      name subordinates { name dept: department.name }\n    } [exists(subordinates)]`\n  )\n  .then((res: any) => console.log(JSON.stringify(res, null, 2)))\nOutput:\n[\n  {\n    \"name\": \"KAYLING\",\n    \"subordinates\": [\n      {\n        \"name\": \"BLAZE\",\n        \"dept\": \"MARKETING\"\n      },\n      {\n        \"name\": \"CLARE\",\n        \"dept\": \"FINANCE\"\n      },\n      {\n        \"name\": \"JONAS\",\n        \"dept\": \"AUDIT\"\n      }\n    ]\n  },\n  {\n    \"name\": \"BLAZE\",\n    \"subordinates\": [\n      {\n        \"name\": \"ADELYN\",\n        \"dept\": \"MARKETING\"\n      },\n      {\n        \"name\": \"WADE\",\n        \"dept\": \"MARKETING\"\n      },\n      {\n        \"name\": \"MADDEN\",\n        \"dept\": \"MARKETING\"\n      },\n      {\n        \"name\": \"TUCKER\",\n        \"dept\": \"MARKETING\"\n      },\n      {\n        \"name\": \"JULIUS\",\n        \"dept\": \"MARKETING\"\n      }\n    ]\n  },\n  {\n    \"name\": \"CLARE\",\n    \"subordinates\": [\n      {\n        \"name\": \"MARKER\",\n        \"dept\": \"FINANCE\"\n      }\n    ]\n  },\n  {\n    \"name\": \"JONAS\",\n    \"subordinates\": [\n      {\n        \"name\": \"SCARLET\",\n        \"dept\": \"AUDIT\"\n      },\n      {\n        \"name\": \"FRANK\",\n        \"dept\": \"AUDIT\"\n      }\n    ]\n  },\n  {\n    \"name\": \"SCARLET\",\n    \"subordinates\": [\n      {\n        \"name\": \"ANDRES\",\n        \"dept\": \"AUDIT\"\n      }\n    ]\n  },\n  {\n    \"name\": \"FRANK\",\n    \"subordinates\": [\n      {\n        \"name\": \"SANDRINE\",\n        \"dept\": \"AUDIT\"\n      }\n    ]\n  }\n]\nIn the query\nemployee {\n  name subordinates { name dept: department.name }\n} [exists(subordinates)]\nwe are asking for the name and list of immediate subordinates of every employee who has any subordinates. For the subordinates, we want their name and the name or their department.","title":"One-to-many Query"},{"location":"/tutorial.html#grouping-query","text":"Run the following TypeScript program:\nimport { OQL } from '@vinctus/oql'\nimport fs from 'fs'\n\nconst oql = new OQL(\n  fs.readFileSync('data-model').toString(),\n  'localhost',\n  5432,\n  'postgres',\n  'postgres',\n  'docker',\n  false,\n  0,\n  10\n)\n\noql\n  .queryMany(\n    `\n    employee { \n      dept: department.name count(*)\n    } /department.dep_id/ <department.name>`\n  )\n  .then((res: any) => console.log(JSON.stringify(res, null, 2)))\nOutput:\n[\n  {\n    \"dept\": \"AUDIT\",\n    \"count\": 5\n  },\n  {\n    \"dept\": \"FINANCE\",\n    \"count\": 3\n  },\n  {\n    \"dept\": \"MARKETING\",\n    \"count\": 6\n  }\n]\nIn the query\nemployee { \n  dept: department.name count(*)\n} /department.dep_id/ <department.name>\nwe are grouping employees by their department id (/department.dep_id/) to get the number of employees for each department. We also want the result to be sorted by department name (<department.name>).","title":"Grouping Query"},{"location":"/api.html","text":"","title":"API"},{"location":"/api.html#api","text":"The TypeScript API is documented first here followed by a few notes on the Scala.js API which is very similar.","title":"API"},{"location":"/api.html#the-oql-class","text":"These are the methods of the OQL class, which are the main methods that you will be using. Brackets around a parameter signify an optional parameter.","title":"The OQL Class"},{"location":"/api.html#count-query-parameters-","text":"Returns a promise for the number of objects where query is the query string written in the OQL query language. If parameters is given, each parameter is referenced in the query as :name where name is the name of the parameter.\nFor example\noql.count('product [price < :max]', {max: 100.00})\ngets the number of products that are less than $100.","title":"count(query, [parameters])"},{"location":"/api.html#entity-name-","text":"Returns a Mutation instance for OQL class instance that it was called on. See The Mutation Class for a method reference.","title":"entity(name)"},{"location":"/api.html#querybuilder-","text":"Returns a QueryBuilder instance for OQL class instance that it was called on. See The QueryBuilder Class for a method reference.","title":"queryBuilder()"},{"location":"/api.html#queryone-query-parameters-","text":"Returns a promise for zero or one object where query is the query string written in the OQL query language. If parameters is given, each parameter is referenced in the query as :name where name is the name of the parameter.\nFor example\noql.queryOne('user {id name email} [id < :id]', {id: 12345})\ngets the id, name, and email for user with id 12345.","title":"queryOne(query, [parameters])"},{"location":"/api.html#querymany-query-parameters-","text":"Returns a promise for an array of objects where query is the query string written in the OQL query language. If parameters is given, each parameter is referenced in the query as :name where name is the name of the parameter.\nFor example\noql.queryMany('product {id name price supplier.name} [price < :max]', {max: 100.00})\ngets the id, name, price and supplier.name for products that are less than $100.","title":"queryMany(query, [parameters])"},{"location":"/api.html#raw-sql-values-","text":"Perform the raw SQL query and return a promise for the results where sql is the query string and values are query parameter values.","title":"raw(sql, [values])"},{"location":"/api.html#the-querybuilder-class","text":"QueryBuilder is used to build up a query step by step. QueryBuilder instances are immutable so each method that returns a QueryBuilder object is returning a new instance.","title":"The QueryBuilder Class"},{"location":"/api.html#cond-exp-","text":"Blocks the next method call in a chain of QueryBuilder calls if the condition expression exp is falsy.","title":"cond(exp)"},{"location":"/api.html#getcount-","text":"Returns a promise for the number of objects that could be retrieved with this query builder.","title":"getCount()"},{"location":"/api.html#getmany-","text":"Returns a promise for an array of object specified by this query builder.","title":"getMany()"},{"location":"/api.html#getone-","text":"Returns a promise for zero or one object specified by this query builder.","title":"getOne()"},{"location":"/api.html#limit-a-","text":"Returns a new query builder with a query limit of a.","title":"limit(a)"},{"location":"/api.html#offset-a-","text":"Returns a new query builder with a query offset of a.","title":"offset(a)"},{"location":"/api.html#order-attribute-sorting-","text":"Returns a new query builder with a query ordering on attribute with sorting direction.","title":"order(attribute, sorting)"},{"location":"/api.html#project-entity-attributes-","text":"Returns a new query builder to query entiry retrieving attributes. This method is a bit more efficient than using query() because it avoids parsing the query.","title":"project(entity, attributes)"},{"location":"/api.html#query-base-query-parameters-","text":"Returns a new query builder with the given base_query, which must be a well-formed OQL query.","title":"query(base_query, [parameters])"},{"location":"/api.html#select-selection-parameters-","text":"Returns a new query builder with the given selection. If a selection has been given, either using query() (with the selection within brackets) or using select(), then this selection will be logically AND’ed with the previous one. There or no need to add parentheses to ensure correct order of operations if the selection contains a logical OR, this is done internally.","title":"select(selection, [parameters])"},{"location":"/api.html#the-mutation-class","text":"These are methods that can be called on a resource object.","title":"The Mutation Class"},{"location":"/api.html#delete-id-","text":"Returns a promise to delete object with primary key id.","title":"delete(id)"},{"location":"/api.html#getmany-","text":"Returns a promise for all objects of this resource.","title":"getMany()"},{"location":"/api.html#insert-obj-","text":"Returns a promise to insert obj into this resource. The promise resolves to an object with the primary key of the inserted object.","title":"insert(obj)"},{"location":"/api.html#link-e1-attribute-e2-","text":"Returns a promise to link object e1 of this resource to object e2 of the type given for attribute.","title":"link(e1, attribute, e2)"},{"location":"/api.html#unlink-e1-attribute-e2-","text":"Returns a promise to unlink object e1 of this resource to object e2 of the type given for attribute.","title":"unlink(e1, attribute, e2)"},{"location":"/api.html#update-e-updates-","text":"Returns a promise to update object e of this resource according to updates.","title":"update(e, updates)"},{"location":"/api.html#bulkupdate-updates-","text":"Returns a promise to apply updates to the table where updates is an array of tuples (arrays with two elements). The first element of each tuple is an id or object containing an id, and the second is an object specifying the updated fields.","title":"bulkUpdate(updates)"},{"location":"/examples.html","text":"","title":"Examples"},{"location":"/examples.html#examples","text":"","title":"Examples"},{"location":"/examples.html#example-many-to-many-","text":"This example presents a very simple “student” database where students are enrolled in classes, so that the students and classes are in a many-to-many relationship. The example has tables and fields that are intentionally poorly named so as to demonstrate the aliasing features of the database modeling language.\nGet PostgreSQL running in a docker container:\ndocker pull postgres\ndocker run --rm --name pg-docker -e POSTGRES_PASSWORD=docker -d -p 5432:5432 postgres\nRun the PostgreSQL terminal to create a database (with password “docker”):\npsql -h localhost -U postgres -d postgres\nwhich can be installed if necessary with the command\nsudo apt-get install postgresql-client\nCreate a simple database by copy-pasting the following (yes, all in one shot) at the psql prompt:\nCREATE DATABASE student;\n\nCREATE TABLE students (\n  id SERIAL PRIMARY KEY,\n  stu_name TEXT\n);\n\nCREATE TABLE class (\n  id SERIAL PRIMARY KEY,\n  name TEXT\n);\n\nCREATE TABLE student_class (\n  studentid INTEGER REFERENCES students (id),\n  classid INTEGER REFERENCES class (id),\n  year INTEGER,\n  semester TEXT,\n  grade TEXT\n);\n\nINSERT INTO students (id, stu_name) VALUES\n  (1, 'John'),\n  (2, 'Debbie');\n\nINSERT INTO class (id, name) VALUES\n  (1, 'English'),\n  (2, 'Maths'),\n  (3, 'Spanish'),\n  (4, 'Biology'),\n  (5, 'Science'),\n  (6, 'Programming'),\n  (7, 'Law'),\n  (8, 'Commerce'),\n  (9, 'Physical Education');\n\nINSERT INTO student_class (studentid, classid, year, semester, grade) VALUES\n  (1, 3, 2019, 'fall', 'B+'),\n  (1, 5, 2018, 'winter', 'A'),\n  (1, 9, 2019, 'summer', 'F'),\n  (2, 1, 2018, 'fall', 'A+'),\n  (2, 4, 2019, 'winter', 'B-'),\n  (2, 5, 2018, 'summer', 'A-'),\n  (2, 9, 2019, 'fall', 'B+');\nThe above database can be modelled using the following diagram:\nCreate a file called student-data-model and copy-paste the following text into it:\nentity class {\n *id: integer\n  name: text\n  students: [student] (enrollment)\n}\n\nentity student (students) {\n *id: integer\n  name (stu_name): text\n  classes: [class] (enrollment)\n}\n\nentity enrollment (student_class) {\n  student (studentid): student\n  class (classid): class\n  year: integer\n  semester: text\n  grade: text\n}\nRun the following TypeScript program:\nimport { OQL } from '@vinctus/oql'\nimport fs from 'fs'\n\nconst oql = new OQL(\n  fs.readFileSync('student-data-model').toString(),\n  'localhost',\n  5432,\n  'postgres',\n  'postgres',\n  'docker',\n  false,\n  0,\n  10\n)\n\noql\n  .queryMany(\n    `\n    student {\n      * classes { * students <name> } <name>\n    } [name = 'John']\n    `\n  )\n  .then((res: any) => console.log(JSON.stringify(res, null, 2)))\nOutput:\n[\n  {\n    \"id\": 1,\n    \"name\": \"John\",\n    \"classes\": [\n      {\n        \"id\": 9,\n        \"name\": \"Physical Education\",\n        \"students\": [\n          {\n            \"id\": 2,\n            \"name\": \"Debbie\"\n          },\n          {\n            \"id\": 1,\n            \"name\": \"John\"\n          }\n        ]\n      },\n      {\n        \"id\": 5,\n        \"name\": \"Science\",\n        \"students\": [\n          {\n            \"id\": 2,\n            \"name\": \"Debbie\"\n          },\n          {\n            \"id\": 1,\n            \"name\": \"John\"\n          }\n        ]\n      },\n      {\n        \"id\": 3,\n        \"name\": \"Spanish\",\n        \"students\": [\n          {\n            \"id\": 1,\n            \"name\": \"John\"\n          }\n        ]\n      }\n    ]\n  }\n]\nThe query\nstudent {\n  * classes { * students <name> } <name>\n} [name = 'John']\nin the above example is asking for the names of the students enrolled only in the classes in which John is enrolled. Also, the query is asking for the classes and the students in each class to be ordered by class name and student name, respectively. The * operator is a wildcard that stands for all attributes that do not result in an array value.\nWith entities that are in a many-to-many relationship, it is possible to query the junction entity that is between them.\nRun the following TypeScript program:\nimport { OQL } from '@vinctus/oql'\nimport fs from 'fs'\n\nconst oql = new OQL(\n  fs.readFileSync('student-data-model').toString(),\n  'localhost',\n  5432,\n  'postgres',\n  'postgres',\n  'docker',\n  false,\n  0,\n  10\n)\n\noql\n  .queryMany(\n    `\n    enrollment {\n      name: student.name\n      classes: count(*)\n      GPA: avg(\n        case\n          when grade = 'A-' then 3.7\n          when grade = 'A' then 4\n          when grade = 'A+' then 4.3\n          when grade = 'B-' then 2.7\n          when grade = 'B' then 3\n          when grade = 'B+' then 3.3\n          when grade = 'F' then 0\n        end\n        )\n    } /student.id/\n    `\n  )\n  .then((res: any) => console.log(JSON.stringify(res, null, 2)))\nOutput:\n[\n  {\n    \"name\": \"Debbie\",\n    \"classes\": 4,\n    \"GPA\": 3.5\n  },\n  {\n    \"name\": \"John\",\n    \"classes\": 3,\n    \"GPA\": 2.433333333333333\n  }\n]\nThe query\nenrollment {\n  name: student.name\n  classes: count(*)\n  GPA: avg(\n    case\n      when grade = 'A-' then 3.7\n      when grade = 'A' then 4\n      when grade = 'A+' then 4.3\n      when grade = 'B-' then 2.7\n      when grade = 'B' then 3\n      when grade = 'B+' then 3.3\n      when grade = 'F' then 0\n    end\n    )\n} /student.id/\nsays, “group all the students who are enrolled and show the name of each enrolled student, how many classes they are enrolled in, and their grade point average”.","title":"Example (many-to-many)"},{"location":"/datatypes.html","text":"","title":"Data types"},{"location":"/datatypes.html#data-types","text":"A data type, in OQL, is distinct from the notion of an attribute type. Specifically, data types are a subclass of attribute type. Any given OQL data type is guaranteed to have the same meaning across supported engines that implement the given data type in some way.","title":"Data types"},{"location":"/datatypes.html#text","text":"In OQL, there is currently a single data type for representing character string or textual data: text.\nThe text data type corresponds to the PostgreSQL TEXT data type and materializes as a TypeScript string primitive or a Scala String type object.","title":"Text"},{"location":"/datatypes.html#numeric","text":"There are four different categories of numerical data currently in OQL.","title":"Numeric"},{"location":"/datatypes.html#integers","text":"These are integers in the range of approximately -2.1 billion to +2.1 billion. In OQL, this is the integer data type, which has two synonyms: int and int4.\nThe integer data type corresponds to the PostgreSQL INTEGER data type and materializes as a TypeScript number primitive or a Scala Int type object.","title":"Integers"},{"location":"/datatypes.html#big-integers","text":"These are integers in the range of approximately -9.2 million trillion to +9.2 million trillion. In OQL, this is the bigint data type, which has synonym int8.\nThe bigint data type corresponds to the PostgreSQL BIGINT data type and materializes as a TypeScript bigint primitive or a Scala Long type object.","title":"Big integers"},{"location":"/datatypes.html#arbitrarily-large-integers","text":"These are integers that can be of any size. In OQL, this is the decimal data type.\nThe decimal(p) data type corresponds to the PostgreSQL NUMERIC(p) data type and materializes as a TypeScript bigint primitive or a Scala BigInt type object.","title":"Arbitrarily large integers"},{"location":"/datatypes.html#double-precision-floating-point","text":"These are floating point numbers in a standard (IEEE 754) double precision binary representation with 15 significant digits. In OQL, this is the float data type, which has one synonym: float8.\nThe float data type corresponds to the PostgreSQL DOUBLE PRECISION data type and materializes as a TypeScript number primitive or a Scala Double type object.","title":"Double precision floating point"},{"location":"/datatypes.html#boolean","text":"The boolean type has three values: TRUE, FALSE, and NULL (representing the unknown state).\nIn OQL, this is the boolean data type, which has one synonym: bool.\nThe boolean data type corresponds to the PostgreSQL BOOLEAN data type and materializes as a TypeScript boolean primitive or a Scala Boolean type object.","title":"Boolean"},{"location":"/datatypes.html#uuid","text":"Universally Unique Identifiers have type uuid which corresponds to the PostgreSQL UUID data type and materializes as a TypeScript string primitive or a Scala String type object.","title":"UUID"},{"location":"/datatypes.html#time-and-date","text":"There are two data types relating to time and date:","title":"Time and Date"},{"location":"/datatypes.html#timestamps","text":"Timestamps are denoted timestamp which corresponds to the PostgreSQL TIMESTAMP WITHOUT TIME ZONE data type and materializes as a TypeScript Date type object or a Scala Instant type object.","title":"Timestamps"},{"location":"/datatypes.html#enumerated-types","text":"OQL provides support for PostgreSQL enumerated (enum) types. The enum needs to be declared (not necessarily before it is used). The syntax for declaring an enum is given here. Other than declaring the enum and then using its name as a type name for attribute types, there’s nothing special that needs to be done to use enums. You can treat them as strings in queries and mutations.","title":"Enumerated Types"},{"location":"/syntax.html","text":"","title":"Syntax"},{"location":"/syntax.html#syntax","text":"The following syntax (or railroad) diagrams of both the data modeling and query language provide a clear description of those languages. The syntax for JSON (JSON syntax) has been omitted.","title":"Syntax"},{"location":"/syntax.html#data-modeling-language","text":"An “Entity-Relationship” style language is used to describe the database. Only the portions of the database for which OQL is being used need to be described.","title":"Data Modeling Language"},{"location":"/syntax.html#data-modeling-grammar-rules","text":"Model The complete data model is a series of declarations. Currently, only entity and enum (enumeration) declarations are supported. Enum Enums (enumerations) correspond to enum types in the database. An enum comprises an identifier matching the name of the corresponding enum type, and an ordered list of text values (not command separated) known as labels. Label Enum labels look like single quoted strings (so that you can have spaces in them). Entity Entities correspond to tables in the database. An entity comprises an identifier matching the name of the corresponding table, which can be given an alias, and a series of attributes. Identifier An identifier can have letters, digits, underscores, and dollar signs, but may not begin with a digit. Alias Aliases are identifiers. Attribute Attributes correspond to columns in a table, if they have a data type, or a simple entity type (i.e., just the name of an entity). An attribute that begins with an asterisk is the primary key. The name of an attribute can be aliased. An attribute that ends with an exclamation mark can’t be null or excluded when inserting. Type There are several kinds of attribute types: DataType corresponding to a database data type. These attributes correspond to table columns that are not foreign keys. EnumName corresponding to a database enum type. EntityName representing the many-to-one relationship (from the point of view of the current entity). This is the entity relationship type that corresponds to a table column that is a foreign key. [ EntityName ] or [ EntityName ] . AttributeName representing the one-to-many relationship (from the point of view of the current entity). This is the array type that represents all the entities (rows) that are referencing the current entity. [ EntityName ] ( EntityName ) or [ EntityName ] . AttributeName ( EntityName ) representing the many-to-many relationship. The second EntityName in parentheses refers to the junction or link entity (table). < EntityName > or < EntityName > . AttributeName representing the one-to-one relationship (the current entity is the one being referenced by a foreign key). DataType Any one of the basic data types that are commonly support by database systems. Any group of datatypes that begin with the same spelling (beyond the first one or two letters) are synonymous (e.g., bool and boolean refer to the same datatype). EnumName An EnumName is an identifier that corresponds to the identifier given as the enum name. EntityName An EntityName is an identifier that corresponds either to the identifier given as the entity name if it wasn’t aliased, or to the alias if it was. AttributeName An AttributeName is an identifier that corresponds either to the identifier given as the attribute name if it wasn’t aliased, or to the alias if it was.","title":"Data Modeling Grammar Rules"},{"location":"/syntax.html#query-language","text":"The query language is inspired by GraphQL. In the following grammar, all keywords (double-quoted string literals) are case-insensitive.","title":"Query Language"},{"location":"/syntax.html#query-grammar-rules","text":"query A data retrieval query expression begins with the name of the entity being queried followed by zero or more optional relational operations: project This relational operation specifies the structure of the result. If omitted, the result will comprise all datatype attributes (i.e., columns that are not foreign keys) only, in the order in which they were defined in the data model. The fact that relational attributes must be explicitly specified prevents circularity as well as the retrieval of, possibly very large amounts of unneeded data. The structure of the result is basically a sequence of expressions each with an (often implicit) label. attributeProject The syntax of an attribute within a project is essentially a possibly optional label, followed by an expression, or an inner query if it is a reference to an array type attribute. label Results are in the form of objects which can are thought of as a list of property/value pairs. Therefore, in order to build a result, the property names have to be known. A label, when it is given becomes the property name of the associated value. If omitted, there are simple obvious rules for inferring it. entityName An entityName is an identifier that names an entity (table) or it’s alias. attributeName An attributeName is an identifier that names a column (attribute) or it’s alias. applyExpression Function application has conventional syntax (e.g., SUM(cost)). Currently, function names pass through transpilation unchecked. attributeExpression An attributeExpression is an identifier that names an attribute, whether it’s a column or not, or it’s alias. qualifiedAttributeExpression This is a reference to an attribute that essentially traverses or dereferences a foreign key. select The select relational operation contains a boolean row selection or filter expression. If omitted, all rows will be retrieved.The row selection condition must be a boolean valued expression. group The group operation contains a series of one or more grouping expressions by which an array result will be grouped. order The order operation contains a series of one or more ordering expressions by which an array result will be ordered. Database engines differ in how they order results that contain null values. OQL guarantees a consistent default behaviour across supported engines. For ascending ordering, nulls are first. For descending ordering, nulls are last. restrict This is really two operations that tend to go together: offsetting or skipping an initial number of results, and limiting the number of results. The first integer is the offset (zero if omitted), and the second is the limit (unlimited if omitted). booleanExpression A booleanExpression is a boolean (true or false) valued expression that may be a disjunction (logical “or”) of two or more boolean valued expressions. andExpression An andExpression is a boolean valued expression that may be a conjunction (logical “and”) of two or more boolean valued expressions. notExpression A notExpression allows a boolean valued expression to be negated. booleanPrimary These are the most basic kinds of boolean valued expressions. expression multiplicative primary identifier string There are two types of string literals: single quoted and double quoted. Single quoted strings are delimited by single quotes, and so cannot contain a single quote unless it is escaped. Double quoted strings are delimited by double quotes, and so cannot contain a double quote unless it is escaped. Strings can have the following characters and escape sequences: any unicode character except for: characters in the range \\x00-\\x1F, character \\x7F backslashes are not allowed unless followed by one of the characters: \\'\"bfnrtu if a backslash is followed by a u, then 4 hexadecimal digits must follow after that","title":"Query Grammar Rules"},{"location":"/supported-engines.html","text":"","title":"Supported Engines"},{"location":"/supported-engines.html#supported-engines","text":"","title":"Supported Engines"},{"location":"/supported-engines.html#postgresql","text":"","title":"PostgreSQL"},{"location":"/supported-engines.html#postgresql-specific-features","text":"","title":"PostgreSQL Specific Features"},{"location":"/tests.html","text":"","title":"Tests"},{"location":"/tests.html#tests","text":"","title":"Tests"},{"location":"/tests.html#requirements","text":"Git (for cloning) Java 11+ sbt (for building and running tests)","title":"Requirements"},{"location":"/tests.html#setup-postgresql","text":"To run the unit test, you will need to get PostgreSQL running in a docker container:\ndocker pull postgres\ndocker run --rm --name pg-docker -e POSTGRES_PASSWORD=docker -d -p 5432:5432 postgres\nThe PostgreSQL client (psql) should be installed. If necessary, it can be installed with the command\nsudo apt-get install postgresql-client","title":"Setup PostgreSQL"},{"location":"/tests.html#clone-the-repository","text":"At the shell terminal go to the folder where the sources will be downloaded, referred to as dev-path/, and type\ngit git@github.com:vinctustech/oql.git\nThis will create folder dev-path/oql.","title":"Clone the repository"},{"location":"/tests.html#build-the-test-database","text":"Type\ncd oql/test\n\nsh start\n\nsh tests\n\nsh build\nThe last few lines of output should be\nCREATE TABLE\nALTER TABLE\nINSERT 0 4\nINSERT 0 4","title":"Build the test database"},{"location":"/tests.html#run-tests","text":"Type\ncd ..\nsbt test\nYou should see\n[info] All tests passed.","title":"Run tests"},{"location":"/release-notes.html","text":"","title":"Release Notes"},{"location":"/release-notes.html#release-notes","text":"","title":"Release Notes"},{"location":"/release-notes.html#1-0-0","text":"This is the first official release of OQL. While the previous release candidate was feature complete for our present purposes, there were some basic features that were missing.\nFeatures added:\nsupport for PostgreSQL BIGINT, which includes support for JavaScript bigint primitives and Scala BigInt numbers support for PostgreSQL ENUM types support for a way for queries to be “fixed” to a particular entity","title":"1.0.0"},{"location":"/release-notes.html#1-0-0-rc-4-2","text":"fixed the handling of timestamp values in inner query array results","title":"1.0.0-RC.4.2"},{"location":"/release-notes.html#1-0-0-rc-4-1","text":"fixed bulk update to work with primary keys that have type UUID.","title":"1.0.0-RC.4.1"},{"location":"/release-notes.html#1-0-0-rc-4","text":"added mutator method bulkUpdate() to use PostgreSQL’s extended UPDATE command for doing bulk updates.","title":"1.0.0-RC.4"},{"location":"/release-notes.html#1-0-0-rc-3-25","text":"fix CASE construction rendering to SQL fix function type resolution","title":"1.0.0-RC.3.25"},{"location":"/release-notes.html#1-0-0-rc-3-24","text":"This is the third feature-complete release candidate.\nChanges include:\nadded NULL keyword to parser removed escaping quotes by doubling other very minor parser fixes","title":"1.0.0-RC.3.24"},{"location":"/release-notes.html#1-0-0-rc-3-23","text":"second feature-complete release candidate fixed a regression: escaping an apostrophe","title":"1.0.0-RC.3.23"},{"location":"/release-notes.html#1-0-0-rc-3-22","text":"first feature-complete release candidate","title":"1.0.0-RC.3.22"}]}